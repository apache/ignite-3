N0
SELECT * FROM nt1_n1, nt2_n2
---
Fragment#2 root
  distribution: single
  executionNodes: [N0]
  exchangeSourceNodes: {3=[N2], 4=[N1]}
  colocationGroup[-1]: {nodes=[N0], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N0=[]}}
  colocationGroup[3]: {nodes=[N0], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N0=[]}}
  colocationGroup[4]: {nodes=[N0], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N0=[]}}
  tree: 
    Project
        fieldNames: [ID0, C10, C20, ID, C1, C2]
        projection: [ID$0, C1$0, C2$0, ID, C1, C2]
        est: (rows=1)
      NestedLoopJoin
          predicate: true
          fieldNames: [ID, C1, C2, ID$0, C1$0, C2$0]
          type: inner
          est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 3
            est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 4
            est: (rows=1)

Fragment#3
  distribution: identity
  executionNodes: [N2]
  targetNodes: [N0]
  colocationGroup[0]: {nodes=[N2], sourceIds=[0], assignments={part_0=N2:1}, partitionsWithConsistencyTokens={N2=[part_0:1]}}
  partitions: [NT2_N2=[N2={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100003)
      TableScan
          table: PUBLIC.NT2_N2
          fieldNames: [ID, C1, C2]
          est: (rows=100003)

Fragment#4
  distribution: identity
  executionNodes: [N1]
  targetNodes: [N0]
  colocationGroup[1]: {nodes=[N1], sourceIds=[1], assignments={part_0=N1:1}, partitionsWithConsistencyTokens={N1=[part_0:1]}}
  partitions: [NT1_N1=[N1={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100001)
      TableScan
          table: PUBLIC.NT1_N1
          fieldNames: [ID, C1, C2]
          est: (rows=100001)
---

N1
SELECT * FROM nt1_n1, nt2_n2
---
Fragment#2 root
  distribution: single
  executionNodes: [N1]
  exchangeSourceNodes: {3=[N2], 4=[N1]}
  colocationGroup[-1]: {nodes=[N1], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N1=[]}}
  colocationGroup[3]: {nodes=[N1], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N1=[]}}
  colocationGroup[4]: {nodes=[N1], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N1=[]}}
  tree: 
    Project
        fieldNames: [ID0, C10, C20, ID, C1, C2]
        projection: [ID$0, C1$0, C2$0, ID, C1, C2]
        est: (rows=1)
      NestedLoopJoin
          predicate: true
          fieldNames: [ID, C1, C2, ID$0, C1$0, C2$0]
          type: inner
          est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 3
            est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 4
            est: (rows=1)

Fragment#3
  distribution: identity
  executionNodes: [N2]
  targetNodes: [N1]
  colocationGroup[0]: {nodes=[N2], sourceIds=[0], assignments={part_0=N2:1}, partitionsWithConsistencyTokens={N2=[part_0:1]}}
  partitions: [NT2_N2=[N2={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100003)
      TableScan
          table: PUBLIC.NT2_N2
          fieldNames: [ID, C1, C2]
          est: (rows=100003)

Fragment#4
  distribution: identity
  executionNodes: [N1]
  targetNodes: [N1]
  colocationGroup[1]: {nodes=[N1], sourceIds=[1], assignments={part_0=N1:1}, partitionsWithConsistencyTokens={N1=[part_0:1]}}
  partitions: [NT1_N1=[N1={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100001)
      TableScan
          table: PUBLIC.NT1_N1
          fieldNames: [ID, C1, C2]
          est: (rows=100001)
---

N0
SELECT * FROM nt1_n1, nt2_n1
---
Fragment#2 root
  distribution: single
  executionNodes: [N0]
  exchangeSourceNodes: {3=[N1], 4=[N1]}
  colocationGroup[-1]: {nodes=[N0], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N0=[]}}
  colocationGroup[3]: {nodes=[N0], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N0=[]}}
  colocationGroup[4]: {nodes=[N0], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N0=[]}}
  tree: 
    Project
        fieldNames: [ID0, C10, C20, ID, C1, C2]
        projection: [ID$0, C1$0, C2$0, ID, C1, C2]
        est: (rows=1)
      NestedLoopJoin
          predicate: true
          fieldNames: [ID, C1, C2, ID$0, C1$0, C2$0]
          type: inner
          est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 3
            est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 4
            est: (rows=1)

Fragment#3
  distribution: identity
  executionNodes: [N1]
  targetNodes: [N0]
  colocationGroup[0]: {nodes=[N1], sourceIds=[0], assignments={part_0=N1:1}, partitionsWithConsistencyTokens={N1=[part_0:1]}}
  partitions: [NT2_N1=[N1={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100002)
      TableScan
          table: PUBLIC.NT2_N1
          fieldNames: [ID, C1, C2]
          est: (rows=100002)

Fragment#4
  distribution: identity
  executionNodes: [N1]
  targetNodes: [N0]
  colocationGroup[1]: {nodes=[N1], sourceIds=[1], assignments={part_0=N1:1}, partitionsWithConsistencyTokens={N1=[part_0:1]}}
  partitions: [NT1_N1=[N1={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100001)
      TableScan
          table: PUBLIC.NT1_N1
          fieldNames: [ID, C1, C2]
          est: (rows=100001)
---

N1
SELECT * FROM nt1_n1, nt2_n1
---
Fragment#2 root
  distribution: single
  executionNodes: [N1]
  exchangeSourceNodes: {3=[N1], 4=[N1]}
  colocationGroup[-1]: {nodes=[N1], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N1=[]}}
  colocationGroup[3]: {nodes=[N1], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N1=[]}}
  colocationGroup[4]: {nodes=[N1], sourceIds=[-1, 3, 4], assignments={}, partitionsWithConsistencyTokens={N1=[]}}
  tree: 
    Project
        fieldNames: [ID0, C10, C20, ID, C1, C2]
        projection: [ID$0, C1$0, C2$0, ID, C1, C2]
        est: (rows=1)
      NestedLoopJoin
          predicate: true
          fieldNames: [ID, C1, C2, ID$0, C1$0, C2$0]
          type: inner
          est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 3
            est: (rows=1)
        Receiver
            fieldNames: [ID, C1, C2]
            sourceFragmentId: 4
            est: (rows=1)

Fragment#3
  distribution: identity
  executionNodes: [N1]
  targetNodes: [N1]
  colocationGroup[0]: {nodes=[N1], sourceIds=[0], assignments={part_0=N1:1}, partitionsWithConsistencyTokens={N1=[part_0:1]}}
  partitions: [NT2_N1=[N1={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100002)
      TableScan
          table: PUBLIC.NT2_N1
          fieldNames: [ID, C1, C2]
          est: (rows=100002)

Fragment#4
  distribution: identity
  executionNodes: [N1]
  targetNodes: [N1]
  colocationGroup[1]: {nodes=[N1], sourceIds=[1], assignments={part_0=N1:1}, partitionsWithConsistencyTokens={N1=[part_0:1]}}
  partitions: [NT1_N1=[N1={0}]]
  tree: 
    Sender
        distribution: single
        targetFragmentId: 2
        est: (rows=100001)
      TableScan
          table: PUBLIC.NT1_N1
          fieldNames: [ID, C1, C2]
          est: (rows=100001)
---
