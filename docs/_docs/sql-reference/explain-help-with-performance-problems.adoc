// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
= How to use EXPLAIN command to identify possible SQL execution performance problems

SQL EXPLAIN is a powerful command used to analyze and understand the execution plan of a query without actually executing it.
Using EXPLAIN, shows the query execution plan, which includes details such as:

- The order in which tables are accessed.
- The type of join operations used (e.g., nested loop, hash join, merge join).
- Any indexes that are used to speed up data retrieval.
- Estimated costs and row counts for different parts of the query.

This information is crucial for optimizing query performance, identifying bottlenecks, and making informed decisions about database schema design and indexing strategies.

SQL EXPLAIN output analysis can help to optimize slow queries execution. Frequent bottlenecks in SQL execution as follows:

- Avoid scanning an entire table, which is frequently the slowest way to access data.
- Avoid scanning non-optimal indexes.
- No optimal join ordering or join algorithm.
- Wrong data colocation choice.

== Full scan instead of index scan is used
Suppose related sql execution flow looks like:
[source,sql]
----
CREATE TABLE t (id INT PRIMARY KEY, col1 VARCHAR);
CREATE INDEX t_col1_idx ON t(col1);
SELECT id FROM t WHERE col1 = '1';
----

And possible EXPLAIN output:
[source,sql]
----
TableScan
    table: PUBLIC.T
    predicate: =(COL1, _UTF-8'1')
    fieldNames: [ID]
    est: (rows=1)
----
We can see a full scan (*TableScan* operator) with predicate.
The choice which scan implementation (**TableScan** or **IndexScan**) need to be used is relates into planner decision.
But if it is expected that index scan more preferable in such a case, it can be fixed manually with HINTS usage approach:
[source,sql]
----
SELECT /*+ FORCE_INDEX(t_col1_idx) */ id FROM t WHERE col1 = '1';
----
Will show a different plan, like:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_COL1_IDX
    type: SORTED
    predicate: =(COL1, _UTF-8'1')
    searchBounds: [ExactBounds [bound=_UTF-8'1']]
    fieldNames: [ID]
    collation: []
    est: (rows=1)
----

== Not optimal indexes are involved
Indexes with less prediction can be chosen, for example schema and query may look as follows:
[source,sql]
----
CREATE TABLE t (id INT PRIMARY KEY, col1 VARCHAR, col2 VARCHAR);
CREATE INDEX t_col1_col2_idx ON T(col1, col2);
CREATE INDEX t_col1_idx ON t(col1);
SELECT id FROM t WHERE col1 = '1' AND col2 = '2';
----
and possible plan:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_COL1_IDX

-- ...cut (here and below all unrelated explain info will be trimmed)
----
We can see that picked index is **T_COL1_IDX** through both predicates **COL1 = '1' AND COL2 = '2'** are involved and looks like more preferable in such a case to use index: **T_COL1_COL2_IDX***.
Optimal plan need to be like:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_COL1_COL2_IDX
    ...
----
We can also use **HINTS** to achieve it:
[source,sql]
----
SELECT /*+ FORCE_INDEX(t_col1_col2_idx) */ id FROM t WHERE col1 = '1' AND col2 = '2';
----
== Unexpected sort operation
By default, sorted indexes store their entries in ascending order. You can adjust the ordering of a sorted index by including the options ASC or DESC.
Lets suppose schema and related query looks like:
[source,sql]
----
CREATE TABLE t1 (id INT PRIMARY KEY, col1 VARCHAR);
CREATE TABLE t2 (id INT PRIMARY KEY, col1 VARCHAR);
CREATE INDEX t1_col1_desc_idx ON t1(col1 DESC);
CREATE INDEX t2_col1_idx ON t2(col1);

SELECT t1.id as t1id, t2.id as t2id FROM t1 JOIN t2 USING (col1);
----
And possible plan:
[source,sql]
----
MergeJoin
    ...
  Sort
      collation: [COL1 ASC]
      ...
    IndexScan
        index: T1_COL1_DESC_IDX
        ...
  IndexScan
      index: T2_COL1_IDX
      ...
----
We can found here **Sort** operator over **IndexScan** it passed here for changing not satisfying ordering from near source (index), it needs to be ASC ordered.
Extra **Sort** operator brings additional performance costs, we can avoid it by appending an index with satisfying sort ordering:

[source,sql]
----
CREATE INDEX t1_col1_idx ON t1(col1);
----
And plan will become like:

[source,sql]
----
MergeJoin
    ...
  IndexScan
      index: T1_COL1_IDX
      ...
  IndexScan
      index: T2_COL1_IDX
      ...
----
== Performance impact of correlated subqueries
SQL-99 allows for nested subqueries at nearly all places within a query.
Ignite 3 supports nested subqueries, it can be correlated or not. Performance of certain complex correlated subqueries may be insufficient. Let`s consider a correlated query:
[source,sql]
----
CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);
CREATE TABLE dept(id INTEGER PRIMARY KEY, name VARCHAR);

SELECT emp.name, (SELECT dept.name FROM dept WHERE emp.dept_id=dept.id)
FROM emp
WHERE emp.salary > 1000;
----
We can see nested correlated subquery here, lets check the plan:
[source,sql]
----
CorrelatedNestedLoopJoin
    ...
  TableScan
      table: PUBLIC.EMP
      filters: >(SALARY, 1000)
      ...
  ColocatedHashAggregate
      ...
      TableScan
          table: PUBLIC.DEPT
          filters: =($cor1.DEPT_ID, ID)
          ...
----
In Ignite 3 there is present some performance issues related to correlated subqueries and as a result:

- Such subqueries may become bottlenecks.
- Queries over even small tables can cause high CPU.
- Certain queries may perform slower than expected.

Plan shows that **CorrelatedNestedLoopJoin** operator is present.
Thus if some performance issues are found in such a case, it would be more
efficient to rewrite for equal query but without nested subquery, like:
[source,sql]
----
SELECT emp.name, dept.name
FROM emp, dept
WHERE emp.salary > 1000 AND emp.dept_id=dept.id;
----
And new plan becomes:
[source,sql]
----
HashJoin
    condition: =(DEPT_ID, ID)
    ....
  TableScan
      table: PUBLIC.EMP
      filters: >(SALARY, 1000)
      ....
  TableScan
      table: PUBLIC.DEPT
      ....
----
Which performs match better than previous one.

== Excessive sort
Lets explain we have an index involved two columns one of them is participate in predicate and other in ordering, or in sql terms:
[source,sql]
----
CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);
CREATE INDEX emp_salary_name_idx ON emp(salary, name);
SELECT dept_id FROM emp WHERE salary = 1 ORDER BY name;
----
Expectations:

- Index need to be used here.
- No additional sort is needed because index is ordered by **name** column is satisfies initial query ordering.

But plan can shows:
[source,sql]
----
Sort
    collation: [NAME ASC]
    ...
  IndexScan
      table: PUBLIC.T
      index: EMP_SALARY_NAME_IDX
      filters: =(SALARY, 1)
      ...
----
We can see - additional **Sort** operator which is redundant here.
A bit query refactoring can help to avoid excessive sort:
[source,sql]
----
SELECT dept_id FROM emp WHERE salary = 1 ORDER BY salary, name;
----
And the plan becomes as follows:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: EMP_SALARY_NAME_IDX
    filters: =(SALARY, 1)
    ...
----
== Colocated data miss
In many cases it is beneficial to colocate different entries if they are often accessed together.
In this way, multi-entry queries are executed on the same node (where the columns are stored). This concept is known as affinity colocation.
Let`s consider schema and follow query:
[source,sql]
----
-- explicitly colocated by (dept_id)
CREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name)) COLOCATE BY(dept_id);

-- miss COLOCATE BY and implicitly colocated by (id, name)
CREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(id, name));

SELECT emp.name, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id;
----
Expect colocated join here, but plan shows that it`s not true:
[source,sql]
----
HashJoin
    ...
  TableScan
      table: PUBLIC.EMP
      ...
  Exchange
      distribution: affinity
      ...
    TableScan
        table: PUBLIC.DEPT
        ...
----
We can see **Exchange** operator between two table scans, which means that predicate involved rows belonging to the same table will be transferred into different nodes, which holds corresponding predicate involved columns but have a different distribution.

After changing 'lost' colocation:
[source,sql]
----
-- explicitly colocated by (dept_id)
CREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name)) COLOCATE BY(dept_id);

-- explicitly colocated by (id)
CREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(id, name)) COLOCATE BY(id);

SELECT emp.name, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id;
----
Possible plan will show correct colocated join:
[source,sql]
----
HashJoin
    ...
  TableScan
      table: PUBLIC.EMP
      ...
  TableScan
      table: PUBLIC.DEPT
      ...
----
Now, both tables are colocated by predicate involved columns. No more intermediate **Exchange** contained in plan,
thus no additional cross nodes data transfer is raised in such a case.

== Select count optimization
Some queries can be optimized to use more optimal plans which brings performance speed up. For example, plan for:
[source,sql]
----
SELECT COUNT(*) FROM emp;
----
Can look like:
[source,sql]
----
SelectCount
    table: [PUBLIC, EMP]
    est: (rows=43)
    ...
----
But there are numerous cases where such optimization is not applicable (transactional guarantees or some other restrictions), in such a case plan can be a bit different and more time consumable for execution.
The same query as above, but with explicit transaction may produce a different plan like:
[source,sql]
----
ReduceSortAggregate
    ...
  Exchange
      ...
    MapSortAggregate
        ...
      TableScan
          table: PUBLIC.EMP
          est: (rows=43)
          ...
----
== Index scan without exact search bounds
Table scans are available in two implementations: direct table scan and scan through index, index scan containing 'predicate' and so-called: 'search bounds'.
Predicate provides final rows comparison and in case when search bounds are absent it degenerates into table scan through index scan (additional store look up) with further predicate comparison which incurs additional performance overhead costs.
Let`s suppose we have schema and query like:
[source,sql]
----
CREATE TABLE t (id INTEGER PRIMARY KEY, col1 DECIMAL(5, 3));
CREATE INDEX t_col1_idx ON t(col1);

SELECT id FROM t WHERE col1 = 43;
----

And possible plan like:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_COL1_IDX
    predicate: =(CAST(COL1):DECIMAL(13, 3), 43.000)
    ...
----
We can see here - only **predicate** which means that **all** rows from index will go through predicate and bring additional performance penalty.

Two type of solutions are acceptable here:
prohibit not optimal index usage or help planner with type derivation (cast).
Hint with **no index** will prohibit index usage:
[source,sql]
----
SELECT /*+ NO_INDEX */ id FROM t WHERE col1 = 43

-- or with direct index mention:

SELECT /*+ NO_INDEX(t_col1_idx) */ id FROM t WHERE col1 = 43
----
Will give possible plan like:
[source,sql]
----
TableScan
    table: PUBLIC.T
    predicate: =(CAST(COL1):DECIMAL(13, 3), 43.000)
    ...
----

Or append additional cast to the same query:

[source,sql]
----
SELECT id FROM t WHERE col1 = 43::DECIMAL(5, 3);
----

[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_COL1_IDX
    predicate: =(COL1, 43.000)
    searchBounds: [ExactBounds [bound=43.000:DECIMAL(5, 3)]]
    ...
----
We can see here both **searchBounds** and **predicate** which means that only exact lookup through index will be involved.


The same case as above but for a bit complicated query:
[source,sql]
----
CREATE TABLE t (id INT PRIMARY KEY, col1 INT);
CREATE INDEX t_col1_asc_idx ON t (col1);

SELECT * FROM t WHERE col1::varchar = SUBSTR(CURRENT_DATE::varchar, 4);
----

Possible plan:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_VAL_ASC_IDX
    predicate: =(CAST(COL1):VARCHAR CHARACTER SET "UTF-8", SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4))
    ...
----
And we also can see that no **search bounds** are involved here.

Try to change it like:

[source,sql]
----
SELECT * FROM t WHERE col1 = SUBSTR(CURRENT_DATE::varchar, 4)::int;
----

And the possible plan will become:
[source,sql]
----
IndexScan
    table: PUBLIC.T
    index: T_COL1_ASC_IDX
    predicate: =(COL1, CAST(SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4)):INTEGER NOT NULL)
    searchBounds: [ExactBounds [bound=CAST(SUBSTR(CAST(CURRENT_DATE):VARCHAR CHARACTER SET "UTF-8" NOT NULL, 4)):INTEGER]]
    ...
----
We can see that **searchBounds** are present - thus more productive execution flow is expected here.


== Colocation usage
As was mentioned above, right colocated columns choice play a sufficient role in further query execution performance.
Let`s suppose that initially tables are created without any thoughts about further usage columns colocations:
[source,sql]
----
-- implicitly colocated by PRIMARY KEY
CREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name));

-- implicitly colocated by PRIMARY KEY
CREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(name, id));
----
And query as follows:
[source,sql]
----
SELECT emp.name, dept.name FROM emp JOIN dept ON emp.dept_id = dept.id AND emp.salary > 1000;
----
Bring plan like:
[source,sql]
----
HashJoin
    ...
  Exchange
      ...
    TableScan
        table: PUBLIC.EMP
        ...
  Exchange
      ...
    TableScan
        table: PUBLIC.DEPT
        ...
----
We can see here two **Exchange** operators which means that all rows are transferred into single node and then joins.
Obviously such execution flow brings sufficient performance penalty and therefore slow query execution. Let`s try to improve it:
[source,sql]
----
CREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name));
CREATE TABLE dept(id INTEGER PRIMARY KEY, name VARCHAR);
----
Now we can see that dependent rows from **emp** table are transferred into appropriate
node where **dept** holds the rows according **DEPT.ID** distribution:
[source,sql]
----
HashJoin
    predicate: =(DEPT_ID, ID)
    ...
  Exchange
      ...
    TableScan
        table: PUBLIC.EMP
        ...
  TableScan
      table: PUBLIC.DEPT
      ...
----
Only one **Exchange** operator for now, which, once again, mean only rows transferring
from **Emp** table to appropriate **DEPT** one.
And finally, both join predicate related columns are colocated:
[source,sql]
----
-- implicit colocation by PRIMARY KEY
CREATE TABLE emp(dept_id INTEGER PRIMARY KEY, name VARCHAR, salary INTEGER);
CREATE TABLE dept(id INTEGER PRIMARY KEY, name VARCHAR);

-- or explicit colocation by COLOCATE BY
CREATE TABLE emp(dept_id INTEGER, name VARCHAR, salary INTEGER, PRIMARY KEY(dept_id, name)) COLOCATE BY(dept_id);
CREATE TABLE dept(id INTEGER, name VARCHAR, PRIMARY KEY(id, name)) COLOCATE BY(id);
----
Now we have emp and dept tables colocated by ID`s also they belong to the same zone.
And plan can look like:
[source,sql]
----
HashJoin
    predicate: =(DEPT_ID, ID)
    ...
  TableScan
      table: PUBLIC.EMP
      ...
  TableScan
      table: PUBLIC.DEPT
      ...
----
No **Exchange** operators are involved which means - no excessive rows transfer is occurred.