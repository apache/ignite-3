// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
= JDBC Driver

Apache Ignite is shipped with JDBC driver that allows processing of distributed data using standard SQL statements like `SELECT`, `INSERT`, `UPDATE`, or `DELETE` directly from the JDBC side. The name of the driver's class is `org.apache.ignite.jdbc.IgniteJdbcDriver`.

NOTE: The JDBC driver shipped with Apache Ignite version 3.2 has been completely reworked to add support for multiple endpoints and link:developers-guide/clients/overview#partition-awareness[partition awareness].
However, this new driver is not compatible with the previous server versions (3.1 and 3.0).
To connect to Ignite 3.1 (and 3.0), you must use the previous version of the driver that shipped with Apache Ignite 3.1.
The server part remains compatible with previous versions of the driver, so the version 3.1 driver can successfully connect to the version 3.2 server.

See also:

* <<Unsupported Mandatory JDBC Features>>
* <<Unsupported Optional JDBC Features>>
* <<JDBC Features with Limited Support>>

== Setting Up

JDBC driver uses the client connector to work with the cluster. For more information on configuring client connector, see link:developers-guide/clients/overview#client-connector-configuration[Client Connector Configuration].

The JDBC connector needs to be included from Maven:

[source, xml, subs="attributes,specialchars"]
----
<dependency>
    <groupId>org.apache.ignite</groupId>
    <artifactId>ignite-jdbc</artifactId>
    <version>3.2.0</version>
</dependency>
----

Here is how you can open a JDBC connection to the cluster node listening on IP address `127.0.0.1`:

[source, java]
----
Connection conn = DriverManager.getConnection("jdbc:ignite:thin://127.0.0.1:10800");
----

The driver connects to one of the cluster nodes and forwards all the queries to it for final execution. The node handles the query distribution and the result's aggregations. Then the result is sent back to the client application.

The JDBC connection string can have an optional list of name-value pairs as parameters after the '?' delimiter. Name and value are separated by the '=' symbol and multiple properties are separated either by an '&' or a ';'.
Separate sign can't be mixed and should be either semicolon or ampersand sign.

[source, java]
----
jdbc:ignite:thin://host[:port][,host[:port][/schema][[?parameter1=value1][&parameter2=value2],...]]
jdbc:ignite:thin://host[:port][,host[:port][/schema][[?parameter1=value1][;parameter2=value2],...]]
----

* `host` is required and defines the host of the cluster node to connect to.
* `port` is the port to use to open the connection. 10800 is used by default if this parameter is omitted.
* `schema` is the schema name to access. PUBLIC is used by default. This name should correspond to the SQL ANSI-99 standard. Non-quoted identifiers are not case sensitive. Quoted identifiers are case sensitive. When semicolon format is used, the schema may be defined as a parameter with name schema.
* `parameters` are optional parameters. The following parameters are available:
** `connectionTimeZone` - Client connection time-zone ID. This property can be used by the client to change the time zone of the session on the server. Affects the interpretation of dates in queries that do not specify the time zone explicitly. If not set, system default on client timezone will be used.
** `queryTimeout` - Number of seconds the driver will wait for a `Statement` object to execute. 0 means there is no limit. Default value: `0`.
** `connectionTimeout` - Number of milliseconds JDBC client will wait for server to respond. 0 means there is no limit. Default value: `0`.
** `username` - username for basic authentication to the cluster.
** `password` - user password for basic authentication to the cluster.
** `sslEnabled` - Determines if SSL is enabled. Possible values: `true`, `false`. Default value: `false`
*** `trustStorePath` - Path to trust store on client side.
*** `trustStorePassword` - Trust store password.
*** `keyStorePath` - Path to key store on client side.
*** `keyStorePassword` - Key store password.
*** `clientAuth` - SSL client authentication. Possible values: `NONE`, `OPTIONAL`, `REQUIRE`.
*** `ciphers` - comma-separated SSL ciphers list.
** `partitionAwarenessMetadataCacheSize` - Size of cache to store partition awareness metadata of queries, in number of entries. Default value: `1024`.

=== Parameter Precedence

If the same parameters are passed by using different means, the JDBC driver prioritizes them in the following way:

1. API arguments passed in the `Connection` objects;
2. Last instance of the parameter in the connection string;
3. Properties object passed during connection.

== Performing Transactions

By default a JDBC connection is in auto-commit mode, and in this mode all its SQL statements will be executed and committed as individual transactions.
To be able to manage the transaction, you must switch connection to non-autocommit mode (see link:https://docs.oracle.com/en/java/javase/11/docs/api/java.sql/java/sql/Connection.html#setAutoCommit(boolean)[java documentation]).
In non-autocommit mode, you can perform `commit` and `rollback` transactions. For more information about transactions, see link:developers-guide/transactions[Performing Transactions].

Here is how you can commit a transaction:

[source, java]
----
// Open the JDBC connection.
Connection conn = DriverManager.getConnection("jdbc:ignite:thin://127.0.0.1:10800");

// Disable auto-commit mode.
conn.setAutoCommit(false);

// Commit a transaction
conn.commit();
----

Here is how you can rollback a transaction:

[source, java]
----
conn.rollback();
----

== Partition Awareness

Partition awareness is supported by the JDBC driver.

See link:developers-guide/clients/overview#partition-awareness[Partition Awareness Overview] for more details.

== Unsupported Mandatory JDBC Features

The following mandatory JDBC features are currently not supported (sorted alphabetically):

* java.sql.Connection#clearWarnings
* java.sql.Connection#getWarnings
* java.sql.Connection#prepareCall
* java.sql.PreparedStatement#getParameterMetaData
* java.sql.PreparedStatement#setAsciiStream
* java.sql.PreparedStatement#setBinaryStream
* java.sql.PreparedStatement#setCharacterStream
* java.sql.ResultSet#clearWarnings
* java.sql.ResultSet#getAsciiStream
* java.sql.ResultSet#getBinaryStream
* java.sql.ResultSet#getCharacterStream
* java.sql.ResultSet#getWarnings
* java.sql.ResultSet#setFetchDirection
* java.sql.Statement#clearWarnings
* java.sql.Statement#getWarnings
* java.sql.Statement#setEscapeProcessing
* java.sql.Statement#setFetchDirection
* java.sql.Statement#setMaxFieldSize

== Unsupported Optional JDBC Features

The following optional JDBC features are currently not supported (sorted alphabetically):

* java.sql.Connection#createArrayOf
* java.sql.Connection#createBlob
* java.sql.Connection#createClob
* java.sql.Connection#createNClob
* java.sql.Connection#createSQLXML
* java.sql.Connection#createStruct
* java.sql.Connection#getTypeMap
* java.sql.Connection#releaseSavepoint
* java.sql.Connection#setSavepoint
* java.sql.Connection#setTypeMap
* java.sql.Driver#getParentLogger
* java.sql.PreparedStatement#getMetaData
* java.sql.PreparedStatement#setArray
* java.sql.PreparedStatement#setBlob
* java.sql.PreparedStatement#setClob
* java.sql.PreparedStatement#setNCharacterStream
* java.sql.PreparedStatement#setNClob
* java.sql.PreparedStatement#setRef
* java.sql.PreparedStatement#setRowId
* java.sql.PreparedStatement#setSQLXML
* java.sql.PreparedStatement#setUnicodeStream
* java.sql.PreparedStatement#setURL
* java.sql.ResultSet#cancelRowUpdates
* java.sql.ResultSet#deleteRow
* java.sql.ResultSet#getArray
* java.sql.ResultSet#getBlob
* java.sql.ResultSet#getClob
* java.sql.ResultSet#getNCharacterStream
* java.sql.ResultSet#getNClob
* java.sql.ResultSet#getRef
* java.sql.ResultSet#getRowId
* java.sql.ResultSet#getSQLXML
* java.sql.ResultSet#getUnicodeStream
* java.sql.ResultSet#insertRow
* java.sql.ResultSet#moveToInsertRow
* java.sql.ResultSet#refreshRow
* java.sql.ResultSet#updateArray
* java.sql.ResultSet#updateAsciiStream
* java.sql.ResultSet#updateBigDecimal
* java.sql.ResultSet#updateBinaryStream
* java.sql.ResultSet#updateBlob
* java.sql.ResultSet#updateBoolean
* java.sql.ResultSet#updateByte
* java.sql.ResultSet#updateBytes
* java.sql.ResultSet#updateCharacterStream
* java.sql.ResultSet#updateClob
* java.sql.ResultSet#updateDate
* java.sql.ResultSet#updateDouble
* java.sql.ResultSet#updateFloat
* java.sql.ResultSet#updateInt
* java.sql.ResultSet#updateLong
* java.sql.ResultSet#updateNCharacterStream
* java.sql.ResultSet#updateNClob
* java.sql.ResultSet#updateNString
* java.sql.ResultSet#updateNull
* java.sql.ResultSet#updateObject
* java.sql.ResultSet#updateRef
* java.sql.ResultSet#updateRow
* java.sql.ResultSet#updateRowId
* java.sql.ResultSet#updateShort
* java.sql.ResultSet#updateSQLXML
* java.sql.ResultSet#updateString
* java.sql.ResultSet#updateTime
* java.sql.ResultSet#updateTimestamp
* java.sql.Statement#getGeneratedKeys
* java.sql.Statement#setCursorName
* java.sql.Statement#setPoolable

== JDBC Features with Limited Support

The following JDBC features are supported only in specific cases:

[cols="1,3",opts="header", stripes=none]
|======
|Feature|Supported Cases
|java.sql.Connection#prepareStatement| autoGeneratedKeys=Statement.NO_GENERATED_KEYS, resultSetType=ResultSet.TYPE_FORWARD_ONLY, resultSetConcurrency=ResultSet.CONCUR_READ_ONLY, null or empty columnIndexes, and null or empty columnNames.
|java.sql.Connection#rollback| Without savepoint.
|java.sql.Statement#execute| autoGeneratedKeys=Statement.NO_GENERATED_KEYS, null or empty columnIndexes, and null or empty columnNames.
|java.sql.Statement#executeUpdate| autoGeneratedKeys=Statement.NO_GENERATED_KEYS, null or empty columnIndexes, and null or empty columnNames.
|java.sql.Statement#getMoreResults| current=Statement.CLOSE_CURRENT_RESULT.
|======