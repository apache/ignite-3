// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
= Apache Ignite With Spring Data

== Overview

Spring Data Framework provides a unified and widely used API that allows abstracting an underlying data storage from the
application layer. Spring Data helps you avoid locking to a specific database vendor, making it easy to switch from one
database to another with minimal efforts. Apache Ignite supports Spring Data JDBC by implementing `IgniteDialect`.

== Maven Configuration

The easiest way to start working with Apache Ignite's Spring Data repository is by adding the following Maven dependencies
to the application's `pom.xml` file:

[tabs]
--
tab:pom.xml[]
[source,xml]
----
<dependency>
    <groupId>org.apache.ignite</groupId>
    <artifactId>ignite-spring-ignite</artifactId>
    <version>${ignite.version}</version>
</dependency>

<dependency>
    <groupId>org.apache.ignite</groupId>
    <artifactId>spring-boot-ignite-client-autoconfigure</artifactId>
    <version>${ignite.version}</version>
</dependency>


----
--

Replace `${ignite.version}` with an actual version of Apache Ignite dependencies you are interested in, respectively.

== Application Configuration

You should provide the following properties to the Spring application:

ignite.client.addresses=${ignite.address}
spring.datasource.url=${ignite.jdbc.connectionString}
spring.datasource.driver-class-name=org.apache.ignite.jdbc.IgniteJdbcDriver

Replace `${ignite.address}` with ignite host and port. For example, `localhost:10800`. Replace ${ignite.jdbc.connectionString} with actual
JDBC connection string, for example `jdbc:ignite:thin://localhost`.

Example of application.properties file:

ignite.client.addresses=127.0.0.1:10800
spring.datasource.url=jdbc:ignite:thin://localhost
spring.datasource.driver-class-name=org.apache.ignite.jdbc.IgniteJdbcDriver

You should also provide `IgniteDialectProvider` by adding the following config to the `resources/META-INF/spring.factories` (create the
file if it doesn't exist):

org.springframework.data.jdbc.repository.config.DialectResolver$JdbcDialectProvider=org.apache.ignite.data.IgniteDialectProvider

== Repository

After the above configuration, you can create spring repositories.
For instance, let's create the first custom repository named `PersonRepository`:

[tabs]
--
tab:Java[]
[source,java]
----
@Repository
public interface PersonRepository extends IgniteRepository<Person, Long> {
    /**
     * Gets all the persons with the given name.
     * @param name Person name.
     * @return A list of Persons with the given first name.
     */
    public List<Person> findByFirstName(String name);

    /**
     * Returns top Person with the specified surname.
     * @param name Person surname.
     * @return Person that satisfy the query.
     */
    public Person findTopByLastNameLike(String name);

    /**
     * Getting ids of all the Person satisfying the custom query from {@link Query} annotation.
     *
     * @param orgId Query parameter.
     * @param pageable Pageable interface.
     * @return A list of Persons' ids.
     */
    @Query("SELECT id FROM Person WHERE orgId > ?")
    public List<Long> selectId(long orgId, Pageable pageable);
}
----
--

* Signatures of custom methods like `findByFirstName(name)` and `findTopByLastNameLike(name)` will be automatically processed and turned
into SQL queries when methods get executed. In addition, `@Query(queryString)` annotation can be used if a concreteâ€‹ SQL
query needs to be executed as a result of a method call.


[CAUTION]
====
[discrete]
A table must be created in Apache Ignite before working with it.


====


== Using Apache Ignite Repositories

Now, you can put data in Ignite using Spring Data API:

[tabs]
--
tab:Java[]
[source,java]
----
TreeMap<Long, Person> persons = new TreeMap<>();

persons.put(1L, new Person(1L, 2000L, "John", "Smith", 15000, "Worked for Apple"));

persons.put(2L, new Person(2L, 2000L, "Brad", "Pitt", 16000, "Worked for Oracle"));

persons.put(3L, new Person(3L, 1000L, "Mark", "Tomson", 10000, "Worked for Sun"));

// Adding data into the repository.
repo.save(persons);
----
--

To query the data, we can use basic CRUD operations or methods that will be automatically turned into Apache Ignite SQL queries:

[tabs]
--
tab:Java[]
[source,java]
----
List<Person> persons = repo.findByFirstName("John");

for (Person person: persons)
    System.out.println("   >>>   " + person);

Person topPerson = repo.findTopByLastNameLike("Smith");

System.out.println("\n>>> Top Person with surname 'Smith': " +
        topPerson.getValue());
----
--
