/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Link Validation Script
 *
 * Scans all Markdown/MDX files in the docs directory and validates:
 * - Internal links to other documentation pages
 * - Anchor links within pages
 * - Relative path links
 *
 * Does not validate:
 * - External URLs (requires network access)
 * - Dynamic links generated by React components
 */

const fs = require('fs');
const path = require('path');

const docsDir = path.join(__dirname, '../docs');
const versionedDocsDir = path.join(__dirname, '../versioned_docs');

// ANSI color codes for output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  gray: '\x1b[90m'
};

// Results tracking
const results = {
  totalFiles: 0,
  totalLinks: 0,
  brokenLinks: [],
  warnings: []
};

/**
 * Find all Markdown/MDX files in a directory recursively
 */
function findMarkdownFiles(dir, fileList = []) {
  if (!fs.existsSync(dir)) {
    return fileList;
  }

  const files = fs.readdirSync(dir);

  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      findMarkdownFiles(filePath, fileList);
    } else if (file.match(/\.(md|mdx)$/)) {
      fileList.push(filePath);
    }
  });

  return fileList;
}

/**
 * Extract markdown links from content
 * Matches [text](url) and [text](url "title") patterns
 */
function extractLinks(content) {
  const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
  const links = [];
  let match;

  while ((match = linkRegex.exec(content)) !== null) {
    const url = match[2].split(/\s+/)[0]; // Remove title if present
    links.push({
      text: match[1],
      url: url,
      line: content.substring(0, match.index).split('\n').length
    });
  }

  return links;
}

/**
 * Check if a link is internal (relative or absolute path within docs)
 */
function isInternalLink(url) {
  // Skip external URLs
  if (url.match(/^(https?:\/\/|mailto:|tel:|#)/)) {
    return false;
  }
  // Internal relative or absolute paths
  return true;
}

/**
 * Resolve link path relative to the source file
 */
function resolveLinkPath(sourcePath, linkUrl) {
  // Remove anchor/hash from URL
  const urlWithoutAnchor = linkUrl.split('#')[0];

  if (!urlWithoutAnchor) {
    // Pure anchor link (#section)
    return null;
  }

  // Skip absolute paths starting with / (these are checked separately)
  if (urlWithoutAnchor.startsWith('/')) {
    return null;
  }

  const sourceDir = path.dirname(sourcePath);
  const resolvedPath = path.resolve(sourceDir, urlWithoutAnchor);

  // Try different extensions
  const possiblePaths = [
    resolvedPath,
    resolvedPath + '.md',
    resolvedPath + '.mdx',
    path.join(resolvedPath, 'index.md'),
    path.join(resolvedPath, 'index.mdx')
  ];

  return possiblePaths;
}

/**
 * Check if a file exists
 */
function fileExists(filePaths) {
  if (!Array.isArray(filePaths)) {
    filePaths = [filePaths];
  }

  return filePaths.some(fp => {
    try {
      return fs.existsSync(fp) && fs.statSync(fp).isFile();
    } catch (e) {
      return false;
    }
  });
}

/**
 * Validate links in a single file
 */
function validateFile(filePath) {
  results.totalFiles++;

  const content = fs.readFileSync(filePath, 'utf8');
  const links = extractLinks(content);

  links.forEach(link => {
    results.totalLinks++;

    if (!isInternalLink(link.url)) {
      // Skip external links
      return;
    }

    const possiblePaths = resolveLinkPath(filePath, link.url);

    if (possiblePaths === null) {
      // Pure anchor link, would need to parse headings to validate
      results.warnings.push({
        file: filePath,
        line: link.line,
        link: link.url,
        message: 'Anchor-only link (not validated)'
      });
      return;
    }

    if (!fileExists(possiblePaths)) {
      results.brokenLinks.push({
        file: filePath,
        line: link.line,
        text: link.text,
        url: link.url,
        resolvedPaths: possiblePaths
      });
    }
  });
}

/**
 * Print results summary
 */
function printResults() {
  console.log('\n' + colors.blue + '=== Link Validation Results ===' + colors.reset);
  console.log(colors.gray + `Scanned ${results.totalFiles} files` + colors.reset);
  console.log(colors.gray + `Found ${results.totalLinks} links` + colors.reset);

  if (results.warnings.length > 0) {
    console.log('\n' + colors.yellow + `--- Warnings (${results.warnings.length}) ---` + colors.reset);
    results.warnings.forEach(warning => {
      console.log(colors.yellow + `  ${path.relative(process.cwd(), warning.file)}:${warning.line}` + colors.reset);
      console.log(colors.gray + `    ${warning.message}: ${warning.link}` + colors.reset);
    });
  }

  if (results.brokenLinks.length > 0) {
    console.log('\n' + colors.red + `!!! Broken Links (${results.brokenLinks.length}) !!!` + colors.reset);
    results.brokenLinks.forEach(broken => {
      console.log(colors.red + `  ${path.relative(process.cwd(), broken.file)}:${broken.line}` + colors.reset);
      console.log(colors.gray + `    Text: "${broken.text}"` + colors.reset);
      console.log(colors.gray + `    URL: ${broken.url}` + colors.reset);
      console.log(colors.gray + `    Tried: ${broken.resolvedPaths[0]}` + colors.reset);
    });
    console.log('\n' + colors.red + 'Link validation FAILED' + colors.reset);
    process.exit(1);
  } else {
    console.log('\n' + colors.green + '<<< All internal links valid' + colors.reset);
  }
}

// Main execution
console.log(colors.blue + '>>> Validating internal links in documentation' + colors.reset);

// Find all markdown files
const files = [
  ...findMarkdownFiles(docsDir),
  ...findMarkdownFiles(versionedDocsDir)
];

console.log(colors.gray + `Found ${files.length} markdown files to scan` + colors.reset);

// Validate each file
files.forEach(validateFile);

// Print results
printResults();
